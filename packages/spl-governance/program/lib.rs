// This file is autogenerated with https://github.com/acheroncrypto/native-to-anchor

use anchor_lang::prelude::*;

declare_id!("11111111111111111111111111111111");

#[program]
pub mod spl_governance {
    use super::*;

    pub fn create_realm(
        ctx: Context<CreateRealm>,
        name: String,
        config_args: RealmConfigArgs,
    ) -> Result<()> {
        Ok(())
    }

    pub fn deposit_governing_tokens(
        ctx: Context<DepositGoverningTokens>,
        amount: u64,
    ) -> Result<()> {
        Ok(())
    }

    pub fn withdraw_governing_tokens(ctx: Context<WithdrawGoverningTokens>) -> Result<()> {
        Ok(())
    }

    pub fn set_governance_delegate(
        ctx: Context<SetGovernanceDelegate>,
        new_governance_delegate: Option<Pubkey>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_governance(
        ctx: Context<CreateGovernance>,
        config: GovernanceConfig,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_program_governance(
        ctx: Context<CreateProgramGovernance>,
        config: GovernanceConfig,
        transfer_upgrade_authority: bool,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_proposal(
        ctx: Context<CreateProposal>,
        name: String,
        description_link: String,
        vote_type: VoteType,
        options: Vec<String>,
        use_deny_option: bool,
        proposal_seed: Pubkey,
    ) -> Result<()> {
        Ok(())
    }

    pub fn add_signatory(ctx: Context<AddSignatory>, signatory: Pubkey) -> Result<()> {
        Ok(())
    }

    pub fn remove_signatory(ctx: Context<RemoveSignatory>, signatory: Pubkey) -> Result<()> {
        Ok(())
    }

    pub fn insert_transaction(
        ctx: Context<InsertTransaction>,
        option_index: u8,
        index: u16,
        hold_up_time: u32,
        instructions: Vec<InstructionData>,
    ) -> Result<()> {
        Ok(())
    }

    pub fn remove_transaction(ctx: Context<RemoveTransaction>) -> Result<()> {
        Ok(())
    }

    pub fn cancel_proposal(ctx: Context<CancelProposal>) -> Result<()> {
        Ok(())
    }

    pub fn sign_off_proposal(ctx: Context<SignOffProposal>) -> Result<()> {
        Ok(())
    }

    pub fn cast_vote(ctx: Context<CastVote>, vote: Vote) -> Result<()> {
        Ok(())
    }

    pub fn finalize_vote(ctx: Context<FinalizeVote>) -> Result<()> {
        Ok(())
    }

    pub fn relinquish_vote(ctx: Context<RelinquishVote>) -> Result<()> {
        Ok(())
    }

    pub fn execute_transaction(ctx: Context<ExecuteTransaction>) -> Result<()> {
        Ok(())
    }

    pub fn create_mint_governance(
        ctx: Context<CreateMintGovernance>,
        config: GovernanceConfig,
        transfer_mint_authorities: bool,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_token_governance(
        ctx: Context<CreateTokenGovernance>,
        config: GovernanceConfig,
        transfer_account_authorities: bool,
    ) -> Result<()> {
        Ok(())
    }

    pub fn set_governance_config(
        ctx: Context<SetGovernanceConfig>,
        config: GovernanceConfig,
    ) -> Result<()> {
        Ok(())
    }

    pub fn flag_transaction_error(ctx: Context<FlagTransactionError>) -> Result<()> {
        Ok(())
    }

    pub fn set_realm_authority(
        ctx: Context<SetRealmAuthority>,
        action: SetRealmAuthorityAction,
    ) -> Result<()> {
        Ok(())
    }

    pub fn set_realm_config(
        ctx: Context<SetRealmConfig>,
        config_args: RealmConfigArgs,
    ) -> Result<()> {
        Ok(())
    }

    pub fn create_token_owner_record(ctx: Context<CreateTokenOwnerRecord>) -> Result<()> {
        Ok(())
    }

    pub fn create_native_treasury(ctx: Context<CreateNativeTreasury>) -> Result<()> {
        Ok(())
    }

    pub fn revoke_governing_tokens(ctx: Context<RevokeGoverningTokens>, amount: u64) -> Result<()> {
        Ok(())
    }

    pub fn refund_proposal_deposit(ctx: Context<RefundProposalDeposit>) -> Result<()> {
        Ok(())
    }

    pub fn complete_proposal(ctx: Context<CompleteProposal>) -> Result<()> {
        Ok(())
    }
}

#[derive(Accounts)]
pub struct CreateRealm<'info> {
    #[account(mut)]
    realm_address: AccountInfo<'info>,
    realm_authority: AccountInfo<'info>,
    community_token_mint: AccountInfo<'info>,
    #[account(mut)]
    community_token_holding_address: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
    rent: Sysvar<'info, Rent>,
    // optional_council_token_mint: AccountInfo<'info>,
    // #[account(mut)]
    // optional_council_token_holding_address: AccountInfo<'info>,
    // #[account(mut)]
    // optional_realm_config_address: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct DepositGoverningTokens<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    governing_token_holding_address: AccountInfo<'info>,
    #[account(mut)]
    governing_token_source: AccountInfo<'info>,
    governing_token_owner: Signer<'info>,
    governing_token_source_authority: Signer<'info>,
    #[account(mut)]
    token_owner_record_address: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
    token_program: Program<'info, Token>,
    realm_config_address: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct WithdrawGoverningTokens<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    governing_token_holding_address: AccountInfo<'info>,
    #[account(mut)]
    governing_token_destination: AccountInfo<'info>,
    governing_token_owner: Signer<'info>,
    #[account(mut)]
    token_owner_record_address: AccountInfo<'info>,
    token_program: Program<'info, Token>,
    realm_config_address: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct SetGovernanceDelegate<'info> {
    governance_authority: Signer<'info>,
    #[account(mut)]
    vote_record_address: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CreateGovernance<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    governance_address: AccountInfo<'info>,
    governed_account_address: AccountInfo<'info>,
    token_owner_record: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
    create_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct CreateProgramGovernance<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    program_governance_address: AccountInfo<'info>,
    governed_program: AccountInfo<'info>,
    #[account(mut)]
    governed_program_data_address: AccountInfo<'info>,
    governed_program_upgrade_authority: Signer<'info>,
    token_owner_record: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    bpf_loader_upgradeable: AccountInfo<'info>,
    system_program: Program<'info, System>,
    create_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct CreateProposal<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    proposal_address: AccountInfo<'info>,
    #[account(mut)]
    governance: AccountInfo<'info>,
    #[account(mut)]
    proposal_owner_record: AccountInfo<'info>,
    governing_token_mint: AccountInfo<'info>,
    governance_authority: Signer<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
    // #[account(mut)]
    // optional_proposal_deposit_address: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct AddSignatory<'info> {
    #[account(mut)]
    proposal: AccountInfo<'info>,
    token_owner_record: AccountInfo<'info>,
    governance_authority: Signer<'info>,
    #[account(mut)]
    signatory_record_address: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct RemoveSignatory<'info> {
    #[account(mut)]
    proposal: AccountInfo<'info>,
    token_owner_record: AccountInfo<'info>,
    governance_authority: Signer<'info>,
    #[account(mut)]
    signatory_record_address: AccountInfo<'info>,
    #[account(mut)]
    beneficiary: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct InsertTransaction<'info> {
    governance: AccountInfo<'info>,
    #[account(mut)]
    proposal: AccountInfo<'info>,
    token_owner_record: AccountInfo<'info>,
    governance_authority: Signer<'info>,
    #[account(mut)]
    proposal_transaction_address: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
    rent: Sysvar<'info, Rent>,
}

#[derive(Accounts)]
pub struct RemoveTransaction<'info> {
    #[account(mut)]
    proposal: AccountInfo<'info>,
    token_owner_record: AccountInfo<'info>,
    governance_authority: Signer<'info>,
    #[account(mut)]
    proposal_transaction: AccountInfo<'info>,
    #[account(mut)]
    beneficiary: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CancelProposal<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    governance: AccountInfo<'info>,
    #[account(mut)]
    proposal: AccountInfo<'info>,
    #[account(mut)]
    proposal_owner_record: AccountInfo<'info>,
    governance_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct SignOffProposal<'info> {
    realm: AccountInfo<'info>,
    governance: AccountInfo<'info>,
    #[account(mut)]
    proposal: AccountInfo<'info>,
    signatory: Signer<'info>,
    // optional_proposal_owner_record: AccountInfo<'info>,
    // #[account(mut)]
    // optional_signatory_record_address: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CastVote<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    governance: AccountInfo<'info>,
    #[account(mut)]
    proposal: AccountInfo<'info>,
    #[account(mut)]
    proposal_owner_record: AccountInfo<'info>,
    #[account(mut)]
    voter_token_owner_record: AccountInfo<'info>,
    governance_authority: Signer<'info>,
    #[account(mut)]
    vote_record_address: AccountInfo<'info>,
    vote_governing_token_mint: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct FinalizeVote<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    governance: AccountInfo<'info>,
    #[account(mut)]
    proposal: AccountInfo<'info>,
    #[account(mut)]
    proposal_owner_record: AccountInfo<'info>,
    governing_token_mint: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct RelinquishVote<'info> {
    realm: AccountInfo<'info>,
    governance: AccountInfo<'info>,
    #[account(mut)]
    proposal: AccountInfo<'info>,
    #[account(mut)]
    token_owner_record: AccountInfo<'info>,
    #[account(mut)]
    vote_record_address: AccountInfo<'info>,
    vote_governing_token_mint: AccountInfo<'info>,
    // optional_governance_authority: Signer<'info>,
    // #[account(mut)]
    // optional_beneficiary: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct ExecuteTransaction<'info> {
    governance: AccountInfo<'info>,
    #[account(mut)]
    proposal: AccountInfo<'info>,
    #[account(mut)]
    proposal_transaction: AccountInfo<'info>,
    instruction_program: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CreateMintGovernance<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    mint_governance_address: AccountInfo<'info>,
    #[account(mut)]
    governed_mint: AccountInfo<'info>,
    governed_mint_authority: Signer<'info>,
    token_owner_record: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    create_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct CreateTokenGovernance<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    token_governance_address: AccountInfo<'info>,
    #[account(mut)]
    governed_token: AccountInfo<'info>,
    governed_token_owner: Signer<'info>,
    token_owner_record: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    token_program: Program<'info, Token>,
    system_program: Program<'info, System>,
    create_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct SetGovernanceConfig<'info> {
    #[account(mut)]
    governance: Signer<'info>,
}

#[derive(Accounts)]
pub struct FlagTransactionError<'info> {
    #[account(mut)]
    proposal: AccountInfo<'info>,
    token_owner_record: AccountInfo<'info>,
    governance_authority: Signer<'info>,
    #[account(mut)]
    proposal_transaction: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct SetRealmAuthority<'info> {
    #[account(mut)]
    realm: AccountInfo<'info>,
    realm_authority: Signer<'info>,
    // optional_new_realm_authority: Signer<'info>,
}

#[derive(Accounts)]
pub struct SetRealmConfig<'info> {
    #[account(mut)]
    realm: AccountInfo<'info>,
    realm_authority: Signer<'info>,
    // optional_council_token_mint: AccountInfo<'info>,
    // #[account(mut)]
    // optional_council_token_holding_address: AccountInfo<'info>,
    // optional_system_program: Program<'info, System>,
    // #[account(mut)]
    // optional_realm_config_address: AccountInfo<'info>,
    // #[account(mut)]
    // optional_payer: Signer<'info>,
}

#[derive(Accounts)]
pub struct CreateTokenOwnerRecord<'info> {
    realm: AccountInfo<'info>,
    governing_token_owner: AccountInfo<'info>,
    #[account(mut)]
    token_owner_record_address: AccountInfo<'info>,
    governing_token_mint: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct CreateNativeTreasury<'info> {
    governance: AccountInfo<'info>,
    #[account(mut)]
    native_treasury_address: AccountInfo<'info>,
    #[account(mut)]
    payer: Signer<'info>,
    system_program: Program<'info, System>,
}

#[derive(Accounts)]
pub struct RevokeGoverningTokens<'info> {
    realm: AccountInfo<'info>,
    #[account(mut)]
    governing_token_holding_address: AccountInfo<'info>,
    #[account(mut)]
    token_owner_record_address: AccountInfo<'info>,
    #[account(mut)]
    governing_token_mint: AccountInfo<'info>,
    revoke_authority: Signer<'info>,
    realm_config_address: AccountInfo<'info>,
    token_program: Program<'info, Token>,
}

#[derive(Accounts)]
pub struct RefundProposalDeposit<'info> {
    proposal: AccountInfo<'info>,
    #[account(mut)]
    proposal_deposit_address: AccountInfo<'info>,
    #[account(mut)]
    proposal_deposit_payer: AccountInfo<'info>,
}

#[derive(Accounts)]
pub struct CompleteProposal<'info> {
    #[account(mut)]
    proposal: AccountInfo<'info>,
    token_owner_record: AccountInfo<'info>,
    complete_proposal_authority: Signer<'info>,
}

#[account]
pub struct GovernanceV2 {
    /// Account type. It can be Uninitialized, Governance, ProgramGovernance, TokenGovernance or MintGovernance
    pub account_type: GovernanceAccountType,

    /// Governance Realm
    pub realm: Pubkey,

    /// Account governed by this Governance and/or PDA identity seed
    /// It can be Program account, Mint account, Token account or any other account
    ///
    /// Note: The account doesn't have to exist. In that case the field is only a PDA seed
    ///
    /// Note: Setting governed_account doesn't give any authority over the governed account
    /// The relevant authorities for specific account types must still be transferred to the Governance PDA
    /// Ex: mint_authority/freeze_authority for a Mint account
    /// or upgrade_authority for a Program account should be transferred to the Governance PDA
    pub governed_account: Pubkey,

    /// Reserved space for future versions
    pub reserved1: u32,

    /// Governance config
    pub config: GovernanceConfig,

    /// Reserved space for versions v2 and onwards
    /// Note 1: V1 accounts must be resized before using this space
    /// Note 2: The reserved space should be used from the end to also allow the config to grow if needed
    pub reserved_v2: Reserved120,

    /// The number of active proposals where active means Draft, SigningOff or Voting state
    ///
    /// Note: The counter was introduced in program V3 and didn't exist in program V1 & V2
    /// If the program is upgraded from program V1 or V2 while there are any outstanding active proposals
    /// the counter won't be accurate until all proposals are transitioned to an inactive final state and the counter reset
    pub active_proposal_count: u64,
}

#[account]
pub struct RealmV1 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// Community mint
    pub community_mint: Pubkey,

    /// Configuration of the Realm
    pub config: RealmConfig,

    /// Reserved space for future versions
    pub reserved: [u8; 6],

    /// The number of proposals in voting state in the Realm
    /// Note: This is field introduced in V2 but it took space from reserved
    /// and we have preserve it for V1 serialization roundtrip
    pub voting_proposal_count: u16,

    /// Realm authority. The authority must sign transactions which update the realm config
    /// The authority should be transferred to Realm Governance to make the Realm self governed through proposals
    pub authority: Option<Pubkey>,

    /// Governance Realm name
    pub name: String,
}

#[account]
pub struct TokenOwnerRecordV1 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// The Realm the TokenOwnerRecord belongs to
    pub realm: Pubkey,

    /// Governing Token Mint the TokenOwnerRecord holds deposit for
    pub governing_token_mint: Pubkey,

    /// The owner (either single or multisig) of the deposited governing SPL Tokens
    /// This is who can authorize a withdrawal of the tokens
    pub governing_token_owner: Pubkey,

    /// The amount of governing tokens deposited into the Realm
    /// This amount is the voter weight used when voting on proposals
    pub governing_token_deposit_amount: u64,

    /// The number of votes cast by TokenOwner but not relinquished yet
    /// Every time a vote is cast this number is increased and it's always decreased when relinquishing a vote regardless of the vote state
    pub unrelinquished_votes_count: u64,

    /// The number of outstanding proposals the TokenOwner currently owns
    /// The count is increased when TokenOwner creates a proposal
    /// and decreased  once it's either voted on (Succeeded or Defeated) or Cancelled
    /// By default it's restricted to 10 outstanding Proposal per token owner
    pub outstanding_proposal_count: u8,

    /// Version introduced in program V3
    pub version: u8,

    /// Reserved space for future versions
    pub reserved: [u8; 6],

    /// A single account that is allowed to operate governance with the deposited governing tokens
    /// It can be delegated to by the governing_token_owner or current governance_delegate
    pub governance_delegate: Option<Pubkey>,
}

#[account]
pub struct GovernanceV1 {
    /// Account type. It can be Uninitialized, Governance, ProgramGovernance, TokenGovernance or MintGovernance
    pub account_type: GovernanceAccountType,

    /// Governance Realm
    pub realm: Pubkey,

    /// Account governed by this Governance and/or PDA identity seed
    /// It can be Program account, Mint account, Token account or any other account
    ///
    /// Note: The account doesn't have to exist. In that case the field is only a PDA seed
    ///
    /// Note: Setting governed_account doesn't give any authority over the governed account
    /// The relevant authorities for specific account types must still be transferred to the Governance PDA
    /// Ex: mint_authority/freeze_authority for a Mint account
    /// or upgrade_authority for a Program account should be transferred to the Governance PDA
    pub governed_account: Pubkey,

    /// Running count of proposals
    pub proposals_count: u32,

    /// Governance config
    pub config: GovernanceConfig,
}

#[account]
pub struct ProposalV1 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// Governance account the Proposal belongs to
    pub governance: Pubkey,

    /// Indicates which Governing Token is used to vote on the Proposal
    /// Whether the general Community token owners or the Council tokens owners vote on this Proposal
    pub governing_token_mint: Pubkey,

    /// Current proposal state
    pub state: ProposalState,

    /// The TokenOwnerRecord representing the user who created and owns this Proposal
    pub token_owner_record: Pubkey,

    /// The number of signatories assigned to the Proposal
    pub signatories_count: u8,

    /// The number of signatories who already signed
    pub signatories_signed_off_count: u8,

    /// The number of Yes votes
    pub yes_votes_count: u64,

    /// The number of No votes
    pub no_votes_count: u64,

    /// The number of the instructions already executed
    pub instructions_executed_count: u16,

    /// The number of instructions included in the proposal
    pub instructions_count: u16,

    /// The index of the the next instruction to be added
    pub instructions_next_index: u16,

    /// When the Proposal was created and entered Draft state
    pub draft_at: i64,

    /// When Signatories started signing off the Proposal
    pub signing_off_at: Option<i64>,

    /// When the Proposal began voting as UnixTimestamp
    pub voting_at: Option<i64>,

    /// When the Proposal began voting as Slot
    /// Note: The slot is not currently used but the exact slot is going to be required to support snapshot based vote weights
    pub voting_at_slot: Option<u64>,

    /// When the Proposal ended voting and entered either Succeeded or Defeated
    pub voting_completed_at: Option<i64>,

    /// When the Proposal entered Executing state
    pub executing_at: Option<i64>,

    /// When the Proposal entered final state Completed or Cancelled and was closed
    pub closed_at: Option<i64>,

    /// Instruction execution flag for ordered and transactional instructions
    /// Note: This field is not used in the current version
    pub execution_flags: InstructionExecutionFlags,

    /// The max vote weight for the Governing Token mint at the time Proposal was decided
    /// It's used to show correct vote results for historical proposals in cases when the mint supply or max weight source changed
    /// after vote was completed.
    pub max_vote_weight: Option<u64>,

    /// The vote threshold percentage at the time Proposal was decided
    /// It's used to show correct vote results for historical proposals in cases when the threshold
    /// was changed for governance config after vote was completed.
    pub vote_threshold: Option<VoteThreshold>,

    /// Proposal name
    pub name: String,

    /// Link to proposal's description
    pub description_link: String,
}

#[account]
pub struct SignatoryRecordV1 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// Proposal the signatory is assigned for
    pub proposal: Pubkey,

    /// The account of the signatory who can sign off the proposal
    pub signatory: Pubkey,

    /// Indicates whether the signatory signed off the proposal
    pub signed_off: bool,
}

#[account]
pub struct VoteRecordV1 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// Proposal account
    pub proposal: Pubkey,

    /// The user who casted this vote
    /// This is the Governing Token Owner who deposited governing tokens into the Realm
    pub governing_token_owner: Pubkey,

    /// Indicates whether the vote was relinquished by voter
    pub is_relinquished: bool,

    /// Voter's vote: Yes/No and amount
    pub vote_weight: VoteWeightV1,
}

#[account]
pub struct NativeTreasury {}

#[account]
pub struct ProgramMetadata {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// The slot when the metadata was captured
    pub updated_at: u64,

    /// The version of the program
    /// Max 11 characters XXX.YYY.ZZZ
    pub version: String,

    /// Reserved
    pub reserved: [u8; 64],
}

#[account]
pub struct ProposalV2 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// Governance account the Proposal belongs to
    pub governance: Pubkey,

    /// Indicates which Governing Token is used to vote on the Proposal
    /// Whether the general Community token owners or the Council tokens owners vote on this Proposal
    pub governing_token_mint: Pubkey,

    /// Current proposal state
    pub state: ProposalState,

    // TODO: add state_at timestamp to have single field to filter recent proposals in the UI
    /// The TokenOwnerRecord representing the user who created and owns this Proposal
    pub token_owner_record: Pubkey,

    /// The number of signatories assigned to the Proposal
    pub signatories_count: u8,

    /// The number of signatories who already signed
    pub signatories_signed_off_count: u8,

    /// Vote type
    pub vote_type: VoteType,

    /// Proposal options
    pub options: Vec<ProposalOption>,

    /// The total weight of the Proposal rejection votes
    /// If the proposal has no deny option then the weight is None
    ///
    /// Only proposals with the deny option can have executable instructions attached to them
    /// Without the deny option a proposal is only non executable survey
    ///
    /// The deny options is also used for off-chain and/or manually executable proposal to make them binding
    /// as opposed to survey only proposals
    pub deny_vote_weight: Option<u64>,

    /// Reserved space for future versions
    /// This field is a leftover from unused veto_vote_weight: Option<u64>
    pub reserved1: u8,

    /// The total weight of  votes
    /// Note: Abstain is not supported in the current version
    pub abstain_vote_weight: Option<u64>,

    /// Optional start time if the Proposal should not enter voting state immediately after being signed off
    /// Note: start_at is not supported in the current version
    pub start_voting_at: Option<i64>,

    /// When the Proposal was created and entered Draft state
    pub draft_at: i64,

    /// When Signatories started signing off the Proposal
    pub signing_off_at: Option<i64>,

    /// When the Proposal began voting as UnixTimestamp
    pub voting_at: Option<i64>,

    /// When the Proposal began voting as Slot
    /// Note: The slot is not currently used but the exact slot is going to be required to support snapshot based vote weights
    pub voting_at_slot: Option<u64>,

    /// When the Proposal ended voting and entered either Succeeded or Defeated
    pub voting_completed_at: Option<i64>,

    /// When the Proposal entered Executing state
    pub executing_at: Option<i64>,

    /// When the Proposal entered final state Completed or Cancelled and was closed
    pub closed_at: Option<i64>,

    /// Instruction execution flag for ordered and transactional instructions
    /// Note: This field is not used in the current version
    pub execution_flags: InstructionExecutionFlags,

    /// The max vote weight for the Governing Token mint at the time Proposal was decided
    /// It's used to show correct vote results for historical proposals in cases when the mint supply or max weight source changed
    /// after vote was completed.
    pub max_vote_weight: Option<u64>,

    /// Max voting time for the proposal if different from parent Governance  (only higher value possible)
    /// Note: This field is not used in the current version
    pub max_voting_time: Option<u32>,

    /// The vote threshold at the time Proposal was decided
    /// It's used to show correct vote results for historical proposals in cases when the threshold
    /// was changed for governance config after vote was completed.
    /// TODO: Use this field to override the threshold from parent Governance (only higher value possible)
    pub vote_threshold: Option<VoteThreshold>,

    /// Reserved space for future versions
    pub reserved: [u8; 64],

    /// Proposal name
    pub name: String,

    /// Link to proposal's description
    pub description_link: String,

    /// The total weight of Veto votes
    pub veto_vote_weight: u64,
}

#[account]
pub struct ProposalDeposit {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// The Proposal the deposit belongs to
    pub proposal: Pubkey,

    /// The account which payed for the deposit
    pub deposit_payer: Pubkey,

    /// Reserved
    pub reserved: [u8; 64],
}

#[account]
pub struct ProposalTransactionV2 {
    /// Governance Account type
    pub account_type: GovernanceAccountType,

    /// The Proposal the instruction belongs to
    pub proposal: Pubkey,

    /// The option index the instruction belongs to
    pub option_index: u8,

    /// Unique transaction index within it's parent Proposal
    pub transaction_index: u16,

    /// Minimum waiting time in seconds for the  instruction to be executed once proposal is voted on
    pub hold_up_time: u32,

    /// Instructions to execute
    /// The instructions will be signed by Governance PDA the Proposal belongs to
    // For example for ProgramGovernance the instruction to upgrade program will be signed by ProgramGovernance PDA
    // All instructions will be executed within a single transaction
    pub instructions: Vec<InstructionData>,

    /// Executed at flag
    pub executed_at: Option<i64>,

    /// Instruction execution status
    pub execution_status: TransactionExecutionStatus,

    /// Reserved space for versions v2 and onwards
    /// Note: V1 accounts must be resized before using this space
    pub reserved_v2: [u8; 8],
}

#[account]
pub struct RealmV2 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// Community mint
    pub community_mint: Pubkey,

    /// Configuration of the Realm
    pub config: RealmConfig,

    /// Reserved space for future versions
    pub reserved: [u8; 6],

    /// Legacy field not used since program V3 any longer
    /// Note: If the field is going to be reused in future version it must be taken under consideration
    /// that for some Realms it might be already set to none zero because it was used as voting_proposal_count before
    pub legacy1: u16,

    /// Realm authority. The authority must sign transactions which update the realm config
    /// The authority should be transferred to Realm Governance to make the Realm self governed through proposals
    pub authority: Option<Pubkey>,

    /// Governance Realm name
    pub name: String,

    /// Reserved space for versions v2 and onwards
    /// Note: V1 accounts must be resized before using this space
    pub reserved_v2: [u8; 128],
}

#[account]
pub struct RealmConfigAccount {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// The realm the config belong to
    pub realm: Pubkey,

    /// Community token config
    pub community_token_config: GoverningTokenConfig,

    /// Council token config
    pub council_token_config: GoverningTokenConfig,

    /// Reserved
    pub reserved: Reserved110,
}

#[account]
pub struct SignatoryRecordV2 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// Proposal the signatory is assigned for
    pub proposal: Pubkey,

    /// The account of the signatory who can sign off the proposal
    pub signatory: Pubkey,

    /// Indicates whether the signatory signed off the proposal
    pub signed_off: bool,

    /// Reserved space for versions v2 and onwards
    /// Note: V1 accounts must be resized before using this space
    pub reserved_v2: [u8; 8],
}

#[account]
pub struct TokenOwnerRecordV2 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// The Realm the TokenOwnerRecord belongs to
    pub realm: Pubkey,

    /// Governing Token Mint the TokenOwnerRecord holds deposit for
    pub governing_token_mint: Pubkey,

    /// The owner (either single or multisig) of the deposited governing SPL Tokens
    /// This is who can authorize a withdrawal of the tokens
    pub governing_token_owner: Pubkey,

    /// The amount of governing tokens deposited into the Realm
    /// This amount is the voter weight used when voting on proposals
    pub governing_token_deposit_amount: u64,

    /// The number of votes cast by TokenOwner but not relinquished yet
    /// Every time a vote is cast this number is increased and it's always decreased when relinquishing a vote regardless of the vote state
    pub unrelinquished_votes_count: u64,

    /// The number of outstanding proposals the TokenOwner currently owns
    /// The count is increased when TokenOwner creates a proposal
    /// and decreased  once it's either voted on (Succeeded or Defeated) or Cancelled
    /// By default it's restricted to 1 outstanding Proposal per token owner
    pub outstanding_proposal_count: u8,

    /// Version of the account layout
    /// Note: In future versions (>program V3) we should introduce GovernanceAccountType::TokenOwnerRecord(version:u8) as a way to version this account (and all other accounts too)
    /// It can't be done in program V3  because it would require to fetch another GovernanceAccountType by the UI and the RPC is already overloaded with all the existing types
    /// The new account type and versioning scheme can be introduced once we migrate UI to use indexer to fetch all the accounts
    /// Once the new versioning scheme is introduced this field can be migrated and removed
    ///
    /// The other issues which need to be addressed before we can cleanup the account versioning code:
    /// 1) Remove the specific governance accounts (ProgramGovernance, TokenGovernance, MintGovernance)
    ///    The only reason they exist is the UI which can't handle the generic use case for those assets
    /// 2) For account layout breaking changes all plugins would have to be upgraded
    /// 3) For account layout changes the Holaplex indexer would have to be upgraded
    /// 4) We should migrate the UI to use the indexer for fetching data and stop using getProgramAccounts
    /// 5) The UI would have to be upgraded to support account migration to the latest version
    /// 6) The client sdk is already messy because of the different program/account versions and it should be cleaned up before we add even more versions.
    pub version: u8,

    /// Reserved space for future versions
    pub reserved: [u8; 6],

    /// A single account that is allowed to operate governance with the deposited governing tokens
    /// It can be delegated to by the governing_token_owner or current governance_delegate
    pub governance_delegate: Option<Pubkey>,

    /// Reserved space for versions v2 and onwards
    /// Note: V1 accounts must be resized before using this space
    pub reserved_v2: [u8; 128],
}

#[account]
pub struct VoteRecordV2 {
    /// Governance account type
    pub account_type: GovernanceAccountType,

    /// Proposal account
    pub proposal: Pubkey,

    /// The user who casted this vote
    /// This is the Governing Token Owner who deposited governing tokens into the Realm
    pub governing_token_owner: Pubkey,

    /// Indicates whether the vote was relinquished by voter
    pub is_relinquished: bool,

    /// The weight of the user casting the vote
    pub voter_weight: u64,

    /// Voter's vote
    pub vote: Vote,

    /// Reserved space for versions v2 and onwards
    /// Note: V1 accounts must be resized before using this space
    pub reserved_v2: [u8; 8],
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum VoteThreshold {
    /// Voting threshold of Yes votes in % required to tip the vote (Approval Quorum)
    /// It's the percentage of tokens out of the entire pool of governance tokens eligible to vote
    /// Note: If the threshold is below or equal to 50% then an even split of votes ex: 50:50 or 40:40 is always resolved as Defeated
    /// In other words a '+1 vote' tie breaker is always required to have a successful vote
    YesVotePercentage(u8),

    /// The minimum number of votes in % out of the entire pool of governance tokens eligible to vote
    /// which must be cast for the vote to be valid
    /// Once the quorum is achieved a simple majority (50%+1) of Yes votes is required for the vote to succeed
    /// Note: Quorum is not implemented in the current version
    QuorumPercentage(u8),

    /// Disabled vote threshold indicates the given voting population (community or council) is not allowed to vote
    /// on proposals for the given Governance
    Disabled,
    //
    // Absolute vote threshold expressed in the voting mint units
    // It can be implemented once Solana runtime supports accounts resizing to accommodate u64 size extension
    // Alternatively we could use the reserved space if it becomes a priority
    // Absolute(u64)
    //
    // Vote threshold which is always accepted
    // It can be used in a setup where the only security gate is proposal creation
    // and once created it's automatically approved
    // Any
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum VoteTipping {
    /// Tip when there is no way for another option to win and the vote threshold
    /// has been reached. This ignores voters withdrawing their votes.
    ///
    /// Currently only supported for the "yes" option in single choice votes.
    Strict,

    /// Tip when an option reaches the vote threshold and has more vote weight
    /// than any other options.
    ///
    /// Currently only supported for the "yes" option in single choice votes.
    Early,

    /// Never tip the vote early.
    Disabled,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct GovernanceConfig {
    /// The type of the vote threshold used for community vote
    /// Note: In the current version only YesVotePercentage and Disabled thresholds are supported
    pub community_vote_threshold: VoteThreshold,

    /// Minimum community weight a governance token owner must possess to be able to create a proposal
    pub min_community_weight_to_create_proposal: u64,

    /// Minimum waiting time in seconds for a transaction to be executed after proposal is voted on
    pub min_transaction_hold_up_time: u32,

    /// The base voting time in seconds for proposal to be open for voting
    /// Voting is unrestricted during the base voting time and any vote types can be cast
    /// The base voting time can be extend by optional cool off time when only negative votes (Veto and Deny) are allowed
    pub voting_base_time: u32,

    /// Conditions under which a Community vote will complete early
    pub community_vote_tipping: VoteTipping,

    /// The type of the vote threshold used for council vote
    /// Note: In the current version only YesVotePercentage and Disabled thresholds are supported
    pub council_vote_threshold: VoteThreshold,

    /// The threshold for Council Veto votes
    pub council_veto_vote_threshold: VoteThreshold,

    /// Minimum council weight a governance token owner must possess to be able to create a proposal
    pub min_council_weight_to_create_proposal: u64,

    /// Conditions under which a Council vote will complete early
    pub council_vote_tipping: VoteTipping,

    /// The threshold for Community Veto votes
    pub community_veto_vote_threshold: VoteThreshold,

    /// Voting cool of time
    pub voting_cool_off_time: u32,

    /// The number of active proposals exempt from the Proposal security deposit
    pub deposit_exempt_proposal_count: u8,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum GovernanceAccountType {
    /// Default uninitialized account state
    Uninitialized,

    /// Top level aggregation for governances with Community Token (and optional Council Token)
    RealmV1,

    /// Token Owner Record for given governing token owner within a Realm
    TokenOwnerRecordV1,

    /// Governance account
    GovernanceV1,

    /// Program Governance account
    ProgramGovernanceV1,

    /// Proposal account for Governance account. A single Governance account can have multiple Proposal accounts
    ProposalV1,

    /// Proposal Signatory account
    SignatoryRecordV1,

    /// Vote record account for a given Proposal.  Proposal can have 0..n voting records
    VoteRecordV1,

    /// ProposalInstruction account which holds an instruction to execute for Proposal
    ProposalInstructionV1,

    /// Mint Governance account
    MintGovernanceV1,

    /// Token Governance account
    TokenGovernanceV1,

    /// Realm config account (introduced in V2)
    RealmConfig,

    /// Vote record account for a given Proposal.  Proposal can have 0..n voting records
    /// V2 adds support for multi option votes
    VoteRecordV2,

    /// ProposalTransaction account which holds instructions to execute for Proposal within a single Transaction
    /// V2 replaces ProposalInstruction and adds index for proposal option and multiple instructions
    ProposalTransactionV2,

    /// Proposal account for Governance account. A single Governance account can have multiple Proposal accounts
    /// V2 adds support for multiple vote options
    ProposalV2,

    /// Program metadata account (introduced in V2)
    /// It stores information about the particular SPL-Governance program instance
    ProgramMetadata,

    /// Top level aggregation for governances with Community Token (and optional Council Token)
    /// V2 adds the following fields:
    /// 1) use_community_voter_weight_addin and use_max_community_voter_weight_addin to RealmConfig
    /// 2) voting_proposal_count / replaced with legacy1 in V3
    /// 3) extra reserved space reserved_v2
    RealmV2,

    /// Token Owner Record for given governing token owner within a Realm
    /// V2 adds extra reserved space reserved_v2
    TokenOwnerRecordV2,

    /// Governance account
    /// V2 adds extra reserved space reserved_v2
    GovernanceV2,

    /// Program Governance account
    /// V2 adds extra reserved space reserved_v2
    ProgramGovernanceV2,

    /// Mint Governance account
    /// V2 adds extra reserved space reserved_v2
    MintGovernanceV2,

    /// Token Governance account
    /// V2 adds extra reserved space reserved_v2
    TokenGovernanceV2,

    /// Proposal Signatory account
    /// V2 adds extra reserved space reserved_v2
    SignatoryRecordV2,

    /// Proposal deposit account
    ProposalDeposit,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum MintMaxVoterWeightSource {
    /// Fraction (10^10 precision) of the governing mint supply is used as max vote weight
    /// The default is 100% (10^10) to use all available mint supply for voting
    SupplyFraction(u64),

    /// Absolute value, irrelevant of the actual mint supply, is used as max voter weight
    Absolute(u64),
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct RealmConfig {
    /// Legacy field introduced and used in V2 as use_community_voter_weight_addin: bool
    /// If the field is going to be reused in future version it must be taken under consideration
    /// that for some Realms it might be already set to 1
    pub legacy1: u8,

    /// Legacy field introduced and used in V2 as use_max_community_voter_weight_addin: bool
    /// If the field is going to be reused in future version it must be taken under consideration
    /// that for some Realms it might be already set to 1
    pub legacy2: u8,

    /// Reserved space for future versions
    pub reserved: [u8; 6],

    /// Min number of voter's community weight required to create a governance
    pub min_community_weight_to_create_governance: u64,

    /// The source used for community mint max vote weight source
    pub community_mint_max_voter_weight_source: MintMaxVoterWeightSource,

    /// Optional council mint
    pub council_mint: Option<Pubkey>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum ProposalState {
    /// Draft - Proposal enters Draft state when it's created
    Draft,

    /// SigningOff - The Proposal is being signed off by Signatories
    /// Proposal enters the state when first Signatory Sings and leaves it when last Signatory signs
    SigningOff,

    /// Taking votes
    Voting,

    /// Voting ended with success
    Succeeded,

    /// Voting on Proposal succeeded and now instructions are being executed
    /// Proposal enter this state when first instruction is executed and leaves when the last instruction is executed
    Executing,

    /// Completed
    Completed,

    /// Cancelled
    Cancelled,

    /// Defeated
    Defeated,

    /// Same as Executing but indicates some instructions failed to execute
    /// Proposal can't be transitioned from ExecutingWithErrors to Completed state
    ExecutingWithErrors,

    /// The Proposal was vetoed
    Vetoed,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum InstructionExecutionFlags {
    /// No execution flags are specified
    /// Instructions can be executed individually, in any order, as soon as they hold_up time expires
    None,

    /// Instructions are executed in a specific order
    /// Note: Ordered execution is not supported in the current version
    /// The implementation requires another account type to track deleted instructions
    Ordered,

    /// Multiple instructions can be executed as a single transaction
    /// Note: Transactions are not supported in the current version
    /// The implementation requires another account type to group instructions within a transaction
    UseTransaction,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct AccountMetaData {
    /// An account's public key
    pub pubkey: Pubkey,
    /// True if an Instruction requires a Transaction signature matching `pubkey`.
    pub is_signer: bool,
    /// True if the `pubkey` can be loaded as a read-write account.
    pub is_writable: bool,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct InstructionData {
    /// Pubkey of the instruction processor that executes this instruction
    pub program_id: Pubkey,
    /// Metadata for what accounts should be passed to the instruction processor
    pub accounts: Vec<AccountMetaData>,
    /// Opaque data passed to the instruction processor
    pub data: Vec<u8>,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum TransactionExecutionStatus {
    /// Transaction was not executed yet
    None,

    /// Transaction was executed successfully
    Success,

    /// Transaction execution failed
    Error,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct ProposalInstructionV1 {
    /// Governance Account type
    pub account_type: GovernanceAccountType,

    /// The Proposal the instruction belongs to
    pub proposal: Pubkey,

    /// Unique instruction index within it's parent Proposal
    pub instruction_index: u16,

    /// Minimum waiting time in seconds for the instruction to be executed once proposal is voted on
    pub hold_up_time: u32,

    /// Instruction to execute
    /// The instruction will be signed by Governance PDA the Proposal belongs to
    // For example for ProgramGovernance the instruction to upgrade program will be signed by ProgramGovernance PDA
    pub instruction: InstructionData,

    /// Executed at flag
    pub executed_at: Option<i64>,

    /// Instruction execution status
    pub execution_status: TransactionExecutionStatus,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum VoteWeightV1 {
    /// Yes vote
    Yes(u64),

    /// No vote
    No(u64),
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum OptionVoteResult {
    /// Vote on the option is not resolved yet
    None,

    /// Vote on the option is completed and the option passed
    Succeeded,

    /// Vote on the option is completed and the option was defeated
    Defeated,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct ProposalOption {
    /// Option label
    pub label: String,

    /// Vote weight for the option
    pub vote_weight: u64,

    /// Vote result for the option
    pub vote_result: OptionVoteResult,

    /// The number of the transactions already executed
    pub transactions_executed_count: u16,

    /// The number of transactions included in the option
    pub transactions_count: u16,

    /// The index of the the next transaction to be added
    pub transactions_next_index: u16,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum MultiChoiceType {
    /// Multiple options can be approved with full weight allocated to each approved option
    FullWeight,

    /// Multiple options can be approved with weight allocated proportionally to the percentage of the total weight
    /// The full weight has to be voted among the approved options, i.e., 100% of the weight has to be allocated
    Weighted,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum VoteType {
    /// Single choice vote with mutually exclusive choices
    /// In the SingeChoice mode there can ever be a single winner
    /// If multiple options score the same highest vote then the Proposal is not resolved and considered as Failed
    /// Note: Yes/No vote is a single choice (Yes) vote with the deny option (No)
    SingleChoice,

    /// Multiple options can be selected with up to max_voter_options per voter
    /// and with up to max_winning_options of successful options
    /// Ex. voters are given 5 options, can choose up to 3 (max_voter_options)
    /// and only 1 (max_winning_options) option can win and be executed
    MultiChoice {
        /// Type of MultiChoice
        #[allow(dead_code)]
        choice_type: MultiChoiceType,

        /// The min number of options a voter must choose
        ///
        /// Note: In the current version the limit is not supported and not enforced
        /// and must always be set to 1
        #[allow(dead_code)]
        min_voter_options: u8,

        /// The max number of options a voter can choose
        ///
        /// Note: In the current version the limit is not supported and not enforced
        /// and must always be set to the number of available options
        #[allow(dead_code)]
        max_voter_options: u8,

        /// The max number of wining options
        /// For executable proposals it limits how many options can be executed for a Proposal
        ///
        /// Note: In the current version the limit is not supported and not enforced
        /// and must always be set to the number of available options
        #[allow(dead_code)]
        max_winning_options: u8,
    },
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum GoverningTokenType {
    /// Liquid token is a token which is fully liquid and the token owner retains full authority over it
    /// Deposit - Yes
    /// Withdraw - Yes
    /// Revoke - No, Realm authority cannot revoke liquid tokens
    Liquid,

    /// Membership token is a token controlled by Realm authority
    /// Deposit - Yes, membership tokens can be deposited to gain governance power
    ///           The membership tokens are conventionally minted into the holding account to keep them out of members possession
    /// Withdraw - No, after membership tokens are deposited they are no longer transferable and can't be withdrawn
    /// Revoke - Yes, Realm authority can Revoke (burn) membership tokens
    Membership,

    /// Dormant token is a token which is only a placeholder and its deposits are not accepted and not used for governance power within the Realm
    ///
    /// The Dormant token type is used when only a single voting population is operational. For example a Multisig starter DAO uses Council only
    /// and sets Community as Dormant to indicate its not utilized for any governance power.
    /// Once the starter DAO decides to decentralise then it can change the Community token to Liquid
    ///
    /// Note: When an external voter weight plugin which takes deposits of the token is used then the type should be set to Dormant
    /// to make the intention explicit
    ///
    /// Deposit - No, dormant tokens can't be deposited into the Realm
    /// Withdraw - Yes, tokens can still be withdrawn from Realm to support scenario where the config is changed while some tokens are still deposited
    /// Revoke - No, Realm authority cannot revoke dormant tokens
    Dormant,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct GoverningTokenConfigArgs {
    /// Indicates whether an external addin program should be used to provide voters weights
    /// If yes then the voters weight program account must be passed to the instruction
    pub use_voter_weight_addin: bool,

    /// Indicates whether an external addin program should be used to provide max voters weight for the token
    /// If yes then the max voter weight program account must be passed to the instruction
    pub use_max_voter_weight_addin: bool,

    /// Governing token type defines how the token is used for governance
    pub token_type: GoverningTokenType,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct RealmConfigArgs {
    /// Indicates whether council_mint should be used
    /// If yes then council_mint account must also be passed to the instruction
    pub use_council_mint: bool,

    /// Min number of community tokens required to create a governance
    pub min_community_weight_to_create_governance: u64,

    /// The source used for community mint max vote weight source
    pub community_mint_max_voter_weight_source: MintMaxVoterWeightSource,

    /// Community token config args
    pub community_token_config_args: GoverningTokenConfigArgs,

    /// Council token config args
    pub council_token_config_args: GoverningTokenConfigArgs,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct GoverningTokenConfigAccountArgs {
    /// Specifies an external plugin program which should be used to provide voters weights
    /// for the given governing token
    pub voter_weight_addin: Option<Pubkey>,

    /// Specifies an external an external plugin program should be used to provide max voters weight
    /// for the given governing token
    pub max_voter_weight_addin: Option<Pubkey>,

    /// Governing token type defines how the token is used for governance power
    pub token_type: GoverningTokenType,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct GoverningTokenConfig {
    /// Plugin providing voter weights for the governing token
    pub voter_weight_addin: Option<Pubkey>,

    /// Plugin providing max voter weight for the governing token
    pub max_voter_weight_addin: Option<Pubkey>,

    /// Governing token type
    pub token_type: GoverningTokenType,

    /// Reserved space for future versions
    pub reserved: [u8; 8],
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct VoteChoice {
    /// The rank given to the choice by voter
    /// Note: The field is not used in the current version
    pub rank: u8,

    /// The voter's weight percentage given by the voter to the choice
    pub weight_percentage: u8,
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum Vote {
    /// Vote approving choices
    Approve(Vec<VoteChoice>),

    /// Vote rejecting proposal
    Deny,

    /// Declare indifference to proposal
    /// Note: Not supported in the current version
    Abstain,

    /// Veto proposal
    Veto,
}

#[error_code]
pub enum GovernanceError {
    /// Invalid instruction passed to program
    #[msg("Invalid instruction passed to program")]
    InvalidInstruction = 500, // Start Governance custom errors from 500 to avoid conflicts with programs invoked via CPI

    /// Realm with the given name and governing mints already exists
    #[msg("Realm with the given name and governing mints already exists")]
    RealmAlreadyExists,

    /// Invalid Realm
    #[msg("Invalid realm")]
    InvalidRealm,

    /// Invalid Governing Token Mint
    #[msg("Invalid Governing Token Mint")]
    InvalidGoverningTokenMint, // 503

    /// Governing Token Owner must sign transaction
    #[msg("Governing Token Owner must sign transaction")]
    GoverningTokenOwnerMustSign,

    /// Governing Token Owner or Delegate  must sign transaction
    #[msg("Governing Token Owner or Delegate  must sign transaction")]
    GoverningTokenOwnerOrDelegateMustSign, // 505

    /// All votes must be relinquished to withdraw governing tokens
    #[msg("All votes must be relinquished to withdraw governing tokens")]
    AllVotesMustBeRelinquishedToWithdrawGoverningTokens,

    /// Invalid Token Owner Record account address
    #[msg("Invalid Token Owner Record account address")]
    InvalidTokenOwnerRecordAccountAddress,

    /// Invalid GoverningMint for TokenOwnerRecord
    #[msg("Invalid GoverningMint for TokenOwnerRecord")]
    InvalidGoverningMintForTokenOwnerRecord, // 508

    /// Invalid Realm for TokenOwnerRecord
    #[msg("Invalid Realm for TokenOwnerRecord")]
    InvalidRealmForTokenOwnerRecord, // 509

    /// Invalid Proposal for ProposalTransaction,
    #[msg("Invalid Proposal for ProposalTransaction,")]
    InvalidProposalForProposalTransaction, // 510

    /// Invalid Signatory account address
    #[msg("Invalid Signatory account address")]
    InvalidSignatoryAddress, // 511

    /// Signatory already signed off
    #[msg("Signatory already signed off")]
    SignatoryAlreadySignedOff, // 512

    /// Signatory must sign
    #[msg("Signatory must sign")]
    SignatoryMustSign, // 513

    /// Invalid Proposal Owner
    #[msg("Invalid Proposal Owner")]
    InvalidProposalOwnerAccount, // 514

    /// Invalid Proposal for VoterRecord
    #[msg("Invalid Proposal for VoterRecord")]
    InvalidProposalForVoterRecord, // 515

    /// Invalid GoverningTokenOwner  for VoteRecord
    #[msg("Invalid GoverningTokenOwner for VoteRecord")]
    InvalidGoverningTokenOwnerForVoteRecord, // 516

    /// Invalid Governance config: Vote threshold percentage out of range"
    #[msg("Invalid Governance config: Vote threshold percentage out of range")]
    InvalidVoteThresholdPercentage, // 517

    /// Proposal for the given Governance, Governing Token Mint and index already exists
    #[msg("Proposal for the given Governance, Governing Token Mint and index already exists")]
    ProposalAlreadyExists, // 518

    /// Token Owner already voted on the Proposal
    #[msg("Token Owner already voted on the Proposal")]
    VoteAlreadyExists, // 519

    /// Owner doesn't have enough governing tokens to create Proposal
    #[msg("Owner doesn't have enough governing tokens to create Proposal")]
    NotEnoughTokensToCreateProposal, // 520

    /// Invalid State: Can't edit Signatories
    #[msg("Invalid State: Can't edit Signatories")]
    InvalidStateCannotEditSignatories, // 521

    /// Invalid Proposal state
    #[msg("Invalid Proposal state")]
    InvalidProposalState, // 522

    /// Invalid State: Can't edit transactions
    #[msg("Invalid State: Can't edit transactions")]
    InvalidStateCannotEditTransactions, // 523

    /// Invalid State: Can't execute transaction
    #[msg("Invalid State: Can't execute transaction")]
    InvalidStateCannotExecuteTransaction, // 524

    /// Can't execute transaction within its hold up time
    #[msg("Can't execute transaction within its hold up time")]
    CannotExecuteTransactionWithinHoldUpTime, // 525

    /// Transaction already executed
    #[msg("Transaction already executed")]
    TransactionAlreadyExecuted, // 526

    /// Invalid Transaction index
    #[msg("Invalid Transaction index")]
    InvalidTransactionIndex, // 527

    /// Transaction hold up time is below the min specified by Governance
    #[msg("Transaction hold up time is below the min specified by Governance")]
    TransactionHoldUpTimeBelowRequiredMin, // 528

    /// Transaction at the given index for the Proposal already exists
    #[msg("Transaction at the given index for the Proposal already exists")]
    TransactionAlreadyExists, // 529

    /// Invalid State: Can't sign off
    #[msg("Invalid State: Can't sign off")]
    InvalidStateCannotSignOff, // 530

    /// Invalid State: Can't vote
    #[msg("Invalid State: Can't vote")]
    InvalidStateCannotVote, // 531

    /// Invalid State: Can't finalize vote
    #[msg("Invalid State: Can't finalize vote")]
    InvalidStateCannotFinalize, // 532

    /// Invalid State: Can't cancel Proposal
    #[msg("Invalid State: Can't cancel Proposal")]
    InvalidStateCannotCancelProposal, // 533

    /// Vote already relinquished
    #[msg("Vote already relinquished")]
    VoteAlreadyRelinquished, // 534

    /// Can't finalize vote. Voting still in progress
    #[msg("Can't finalize vote. Voting still in progress")]
    CannotFinalizeVotingInProgress, // 535

    /// Proposal voting time expired
    #[msg("Proposal voting time expired")]
    ProposalVotingTimeExpired, // 536

    /// Invalid Signatory Mint
    #[msg("Invalid Signatory Mint")]
    InvalidSignatoryMint, // 537

    /// Proposal does not belong to the given Governance
    #[msg("Proposal does not belong to the given Governance")]
    InvalidGovernanceForProposal, // 538

    /// Proposal does not belong to given Governing Mint"
    #[msg("Proposal does not belong to given Governing Mint")]
    InvalidGoverningMintForProposal, // 539

    /// Current mint authority must sign transaction
    #[msg("Current mint authority must sign transaction")]
    MintAuthorityMustSign, // 540

    /// Invalid mint authority
    #[msg("Invalid mint authority")]
    InvalidMintAuthority, // 542

    /// Mint has no authority
    #[msg("Mint has no authority")]
    MintHasNoAuthority, // 542

    /// ---- SPL Token Tools Errors ----

    /// Invalid Token account owner
    #[msg("Invalid Token account owner")]
    SplTokenAccountWithInvalidOwner, // 543

    /// Invalid Mint account owner
    #[msg("Invalid Mint account owner")]
    SplTokenMintWithInvalidOwner, // 544

    /// Token Account is not initialized
    #[msg("Token Account is not initialized")]
    SplTokenAccountNotInitialized, // 545

    /// Token Account doesn't exist
    #[msg("Token Account doesn't exist")]
    SplTokenAccountDoesNotExist, // 546

    /// Token account data is invalid
    #[msg("Token account data is invalid")]
    SplTokenInvalidTokenAccountData, // 547

    /// Token mint account data is invalid
    #[msg("Token mint account data is invalid")]
    SplTokenInvalidMintAccountData, // 548

    /// Token Mint is not initialized
    #[msg("Token Mint account is not initialized")]
    SplTokenMintNotInitialized, // 549

    /// Token Mint account doesn't exist
    #[msg("Token Mint account doesn't exist")]
    SplTokenMintDoesNotExist, // 550

    /// ---- Bpf Upgradable Loader Tools Errors ----

    /// Invalid ProgramData account Address
    #[msg("Invalid ProgramData account address")]
    InvalidProgramDataAccountAddress, // 551

    /// Invalid ProgramData account data
    #[msg("Invalid ProgramData account Data")]
    InvalidProgramDataAccountData, // 552

    /// Provided upgrade authority doesn't match current program upgrade authority
    #[msg("Provided upgrade authority doesn't match current program upgrade authority")]
    InvalidUpgradeAuthority, // 553

    /// Current program upgrade authority must sign transaction
    #[msg("Current program upgrade authority must sign transaction")]
    UpgradeAuthorityMustSign, // 554

    /// Given program is not upgradable
    #[msg("Given program is not upgradable")]
    ProgramNotUpgradable, // 555

    /// Invalid token owner
    #[msg("Invalid token owner")]
    InvalidTokenOwner, // 556

    /// Current token owner must sign transaction
    #[msg("Current token owner must sign transaction")]
    TokenOwnerMustSign, // 557

    /// Given VoteThresholdType is not supported
    #[msg("Given VoteThresholdType is not supported")]
    VoteThresholdTypeNotSupported, // 558

    /// Given VoteWeightSource is not supported
    #[msg("Given VoteWeightSource is not supported")]
    VoteWeightSourceNotSupported, // 559

    /// Legacy1
    #[msg("Legacy1")]
    Legacy1, // 560

    /// Governance PDA must sign
    #[msg("Governance PDA must sign")]
    GovernancePdaMustSign, // 561

    /// Transaction already flagged with error
    #[msg("Transaction already flagged with error")]
    TransactionAlreadyFlaggedWithError, // 562

    /// Invalid Realm for Governance
    #[msg("Invalid Realm for Governance")]
    InvalidRealmForGovernance, // 563

    /// Invalid Authority for Realm
    #[msg("Invalid Authority for Realm")]
    InvalidAuthorityForRealm, // 564

    /// Realm has no authority
    #[msg("Realm has no authority")]
    RealmHasNoAuthority, // 565

    /// Realm authority must sign
    #[msg("Realm authority must sign")]
    RealmAuthorityMustSign, // 566

    /// Invalid governing token holding account
    #[msg("Invalid governing token holding account")]
    InvalidGoverningTokenHoldingAccount, // 567

    /// Realm council mint change is not supported
    #[msg("Realm council mint change is not supported")]
    RealmCouncilMintChangeIsNotSupported, // 568

    /// Invalid max voter weight absolute value
    #[msg("Invalid max voter weight absolute value")]
    InvalidMaxVoterWeightAbsoluteValue, // 569

    /// Invalid max voter weight supply fraction
    #[msg("Invalid max voter weight supply fraction")]
    InvalidMaxVoterWeightSupplyFraction, // 570

    /// Owner doesn't have enough governing tokens to create Governance
    #[msg("Owner doesn't have enough governing tokens to create Governance")]
    NotEnoughTokensToCreateGovernance, // 571

    /// Too many outstanding proposals
    #[msg("Too many outstanding proposals")]
    TooManyOutstandingProposals, // 572

    /// All proposals must be finalized to withdraw governing tokens
    #[msg("All proposals must be finalized to withdraw governing tokens")]
    AllProposalsMustBeFinalisedToWithdrawGoverningTokens, // 573

    /// Invalid VoterWeightRecord for Realm
    #[msg("Invalid VoterWeightRecord for Realm")]
    InvalidVoterWeightRecordForRealm, // 574

    /// Invalid VoterWeightRecord for GoverningTokenMint
    #[msg("Invalid VoterWeightRecord for GoverningTokenMint")]
    InvalidVoterWeightRecordForGoverningTokenMint, // 575

    /// Invalid VoterWeightRecord for TokenOwner
    #[msg("Invalid VoterWeightRecord for TokenOwner")]
    InvalidVoterWeightRecordForTokenOwner, // 576

    /// VoterWeightRecord expired
    #[msg("VoterWeightRecord expired")]
    VoterWeightRecordExpired, // 577

    /// Invalid RealmConfig for Realm
    #[msg("Invalid RealmConfig for Realm")]
    InvalidRealmConfigForRealm, // 578

    /// TokenOwnerRecord already exists
    #[msg("TokenOwnerRecord already exists")]
    TokenOwnerRecordAlreadyExists, // 579

    /// Governing token deposits not allowed
    #[msg("Governing token deposits not allowed")]
    GoverningTokenDepositsNotAllowed, // 580

    /// Invalid vote choice weight percentage
    #[msg("Invalid vote choice weight percentage")]
    InvalidVoteChoiceWeightPercentage, // 581

    /// Vote type not supported
    #[msg("Vote type not supported")]
    VoteTypeNotSupported, // 582

    /// InvalidProposalOptions
    #[msg("Invalid proposal options")]
    InvalidProposalOptions, // 583

    /// Proposal is not not executable
    #[msg("Proposal is not not executable")]
    ProposalIsNotExecutable, // 584

    /// Deny vote is not allowed
    #[msg("Deny vote is not allowed")]
    DenyVoteIsNotAllowed, // 585

    /// Cannot execute defeated option
    #[msg("Cannot execute defeated option")]
    CannotExecuteDefeatedOption, // 586

    /// VoterWeightRecord invalid action
    #[msg("VoterWeightRecord invalid action")]
    VoterWeightRecordInvalidAction, // 587

    /// VoterWeightRecord invalid action target
    #[msg("VoterWeightRecord invalid action target")]
    VoterWeightRecordInvalidActionTarget, // 588

    /// Invalid MaxVoterWeightRecord for Realm
    #[msg("Invalid MaxVoterWeightRecord for Realm")]
    InvalidMaxVoterWeightRecordForRealm, // 589

    /// Invalid MaxVoterWeightRecord for GoverningTokenMint
    #[msg("Invalid MaxVoterWeightRecord for GoverningTokenMint")]
    InvalidMaxVoterWeightRecordForGoverningTokenMint, // 590

    /// MaxVoterWeightRecord expired
    #[msg("MaxVoterWeightRecord expired")]
    MaxVoterWeightRecordExpired, // 591

    /// Not supported VoteType
    #[msg("Not supported VoteType")]
    NotSupportedVoteType, // 592

    /// RealmConfig change not allowed
    #[msg("RealmConfig change not allowed")]
    RealmConfigChangeNotAllowed, // 593

    /// GovernanceConfig change not allowed
    #[msg("GovernanceConfig change not allowed")]
    GovernanceConfigChangeNotAllowed, // 594

    /// At least one VoteThreshold is required
    #[msg("At least one VoteThreshold is required")]
    AtLeastOneVoteThresholdRequired, // 595

    /// Reserved buffer must be empty
    #[msg("Reserved buffer must be empty")]
    ReservedBufferMustBeEmpty, // 596

    /// Cannot Relinquish in Finalizing state
    #[msg("Cannot Relinquish in Finalizing state")]
    CannotRelinquishInFinalizingState, // 597

    /// Invalid RealmConfig account address
    #[msg("Invalid RealmConfig account address")]
    InvalidRealmConfigAddress, // 598

    /// Cannot deposit dormant tokens
    #[msg("Cannot deposit dormant tokens")]
    CannotDepositDormantTokens, // 599

    /// Cannot withdraw membership tokens
    #[msg("Cannot withdraw membership tokens")]
    CannotWithdrawMembershipTokens, // 600

    /// Cannot revoke GoverningTokens
    #[msg("Cannot revoke GoverningTokens")]
    CannotRevokeGoverningTokens, // 601

    /// Invalid Revoke amount
    #[msg("Invalid Revoke amount")]
    InvalidRevokeAmount, // 602

    /// Invalid GoverningToken source
    #[msg("Invalid GoverningToken source")]
    InvalidGoverningTokenSource, // 603

    /// Cannot change community TokenType to Membership
    #[msg("Cannot change community TokenType to Membership")]
    CannotChangeCommunityTokenTypeToMembership, // 604

    /// Voter weight threshold disabled
    #[msg("Voter weight threshold disabled")]
    VoterWeightThresholdDisabled, // 605

    /// Vote not allowed in cool off time
    #[msg("Vote not allowed in cool off time")]
    VoteNotAllowedInCoolOffTime, // 606

    /// Cannot refund ProposalDeposit
    #[msg("Cannot refund ProposalDeposit")]
    CannotRefundProposalDeposit, // 607

    ///Invalid Proposal for ProposalDeposit
    #[msg("Invalid Proposal for ProposalDeposit")]
    InvalidProposalForProposalDeposit, // 608

    /// Invalid deposit_exempt_proposal_count
    #[msg("Invalid deposit_exempt_proposal_count")]
    InvalidDepositExemptProposalCount, // 609

    /// GoverningTokenMint not allowed to vote
    #[msg("GoverningTokenMint not allowed to vote")]
    GoverningTokenMintNotAllowedToVote, // 610

    ///Invalid deposit Payer for ProposalDeposit
    #[msg("Invalid deposit Payer for ProposalDeposit")]
    InvalidDepositPayerForProposalDeposit, // 611

    /// Invalid State: Proposal is not in final state
    #[msg("Invalid State: Proposal is not in final state")]
    InvalidStateNotFinal, // 612

    ///Invalid state for proposal state transition to Completed
    #[msg("Invalid state for proposal state transition to Completed")]
    InvalidStateToCompleteProposal, // 613

    /// Invalid number of vote choices
    #[msg("Invalid number of vote choices")]
    InvalidNumberOfVoteChoices, // 614

    /// Ranked vote is not supported
    #[msg("Ranked vote is not supported")]
    RankedVoteIsNotSupported, // 615

    /// Choice weight must be 100%
    #[msg("Choice weight must be 100%")]
    ChoiceWeightMustBe100Percent, // 616

    /// Single choice only is allowed
    #[msg("Single choice only is allowed")]
    SingleChoiceOnlyIsAllowed, // 617

    /// At least single choice is required
    #[msg("At least single choice is required")]
    AtLeastSingleChoiceIsRequired, // 618

    /// Total vote weight must be 100%
    #[msg("Total vote weight must be 100%")]
    TotalVoteWeightMustBe100Percent, // 619

    /// Invalid multi choice proposal parameters
    #[msg("Invalid multi choice proposal parameters")]
    InvalidMultiChoiceProposalParameters, // 620
}

#[derive(AnchorSerialize, AnchorDeserialize)]
pub enum SetRealmAuthorityAction {
    /// Sets realm authority without any checks
    /// Uncheck option allows to set the realm authority to non governance accounts
    SetUnchecked,

    /// Sets realm authority and checks the new new authority is one of the realm's governances
    // Note: This is not a security feature because governance creation is only gated with min_community_weight_to_create_governance
    //       The check is done to prevent scenarios where the authority could be accidentally set to a wrong or none existing account
    SetChecked,

    /// Removes realm authority
    Remove,
}
